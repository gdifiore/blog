<p>Another day, another mitigation. The ARMv8.5 specifications include an optional extension for a feature called “Memory Tagging”. With this introduction, it is likely to be included in the next generations of security-focused phones (iPhone 12?), but What is it? How does it work? and What threat does it pose to security researchers and jailbreakers?</p>

<h2 id="why-memory-tagging">Why Memory Tagging?</h2>

<blockquote>
  <p>According to a 2019 BlueHat presentation, 70 percent of all security issues addressed in Microsoft products are caused by violations of memory safety. Similar figures have been reported by Google for Android where over 75 percent of vulnerabilities are violations of memory safety.</p>
</blockquote>

<p>(Credit <a href="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/enhancing-memory-safety">Steve Bannister</a>)</p>

<h2 id="what-is-memory-tagging">What is Memory Tagging?</h2>

<p>Put simply, when the feature is enabled on a chip, a tag is assigned to each memory allocation, and if that memory is to be accessed it must be made via a pointer with the correct tag. If not, it is reported to the process and it will quit or fail.</p>

<p><img src="https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-21-42/Memory_5F00_Tagging_5F00_Blog_5F00_1040x1040.png" alt="Image from ARM to help isualize memory tagging" />
(Credit: ARM)</p>

<p>Using this diagram from ARM we can see a region of memory with different allocations of said memory being denoted by colors. Imagine that the color represents the tag that is required for the memory to be accessed. The request at 0x8000 would succeed because the pointer has the same color (tag) as the region of memory it is trying to access. Whereas the request at 0x9000 would fail because the pointer has a different color (tag) from the region of memory.</p>

<p>According to ARM, the extension impliments</p>
<blockquote>
  <ul>
    <li>Tag load and store instructions to access Allocation tags in a tag physical address space, separate to the data physical address space accessed by data load and store instructions to access data in normal memory and devices</li>
    <li>4-bit Allocation Tags at a granularity of one Allocation Tag for each naturally-aligned set of 16 physically addressed locations</li>
    <li>System register and page level control over access to Allocation Tags in memory</li>
    <li>A Logical Address Tag from which a Physical Address Tag can be derived and held in the upper bits of the address that is used in load and store data instructions</li>
    <li>A Tag Check of the Physical Address Tag against the 4-bit Allocation Tag for each data location that is accessed by a Tag Checked load or store of data</li>
    <li>Instructions to generate and manipulate the Logical Address Tag in a register</li>
  </ul>
</blockquote>

<h2 id="how-does-it-work">How does it work?</h2>

<p><strong>Terminology</strong>:
TG - Tagging Granule
TS - Tag Size</p>

<p>Tags are generated by a random tag generator held in RGSR_EL1 which is controlled by GCR_EL1.</p>

<p>In AARCH64 pointers, up to 8 bits of a 64bit pointer are allowed to be a tag value. When a region of memory is alllocated with <code class="language-plaintext highlighter-rouge">malloc()</code>, a tag is set to the <em>entire chunk and the corresponding pointer</em>, so that during load and store operations of that memory the tags are validated. If that fails, it will raise an exception to the process and fail.</p>

<p>Let’s consider a heap allocation of 20 bytes with a 4 bit TS and 16 byte TG.</p>

<p><img src="https://seqred.pl/wp-content/uploads/2019/02/Memory_tagging_1.jpg" alt="Image from SEQRED to visualize allocation" />
(Credit: SEQRED)</p>

<p>20 bytes need to be allocated, and the memory allocator aligns it to 32 bytes because of the 16 byte TG. The allocator then chooses the tag (marked in green above) and places it in the 4 most significant bits of memory and the pointer. When dereferencing pointer p at position 32, the tag values won’t correspond, and the buffer overflow will be caught and reported (below).</p>

<p><img src="https://seqred.pl/wp-content/uploads/2019/02/Memory_tagging_2a.jpg" alt="Image from SEQRED to visualize dereferencing" />
(Credit: SEQRED)</p>

<p>And if a previously allocated heap chunk is deleted, it will be re-tagged. After deallocation, if there is a dangling pointer pointing to the re-tagged memory, if it is dereferenced the Use-After-Free will be caught (below).</p>

<p><img src="https://seqred.pl/wp-content/uploads/2019/02/Memory_tagging_3a.jpg" alt="Image from SEQRED to visualize re-tagged memory" />
(Credit: SEQRED)</p>

<h2 id="new-arm-instructions">New ARM Instructions</h2>

<p>Full list of new instructions can be found in the <a href="https://static.docs.arm.com/ddi0487/fa/DDI0487F_a_armv8_arm.pdf">Arm Architecture Reference Manual</a>, but here are some important ones.</p>

<hr />

<blockquote>
  <p>Insert Random Tag inserts a random Logical Address Tag into the address in the first source register, and writes the result to the destination register.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">IRG &lt;Xd|SP&gt;, &lt;Xn|SP&gt;{, \&lt;Xm&gt;}</code></strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;Xd|SP&gt;</code> Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the “Xd” field.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;Xn|SP&gt;</code> Is the 64-bit name of the first source general-purpose register or stack pointer, encoded in the “Xn” field.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;Xm&gt;</code> Is the 64-bit name of the second general-purpose source register, encoded in the “Xm” field. Defaults to XZR if absent.</li>
</ul>

<hr />

<blockquote>
  <p>Load Allocation Tag loads an Allocation Tag from a memory address, generates a Logical Address Tag from the Allocation Tag and merges it into the destination register.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">LDG &lt;Xt&gt;, [&lt;Xn|SP&gt;{, #&lt;simm&gt;}]</code></strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;Xt&gt;</code> Is the 64-bit name of the general-purpose register to be transferred, encoded in the “Xt” field.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;Xn|SP&gt;</code> Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the “Xn” field.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;simm&gt;</code> Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the “imm9” field.</li>
</ul>

<hr />

<blockquote>
  <p>Store Allocation Tag and Pair of registers stores an Allocation Tag and two 64-bit doublewords to memory, from two registers.</p>
</blockquote>

<p>This instruction has multiple variants: post-index, pre-index, and signed offset.</p>

<p><strong>Post-index</strong>
<strong><code class="language-plaintext highlighter-rouge">STGP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;], #&lt;imm&gt;</code></strong></p>

<p><strong>Pre-index</strong>
<strong><code class="language-plaintext highlighter-rouge">STGP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;, #&lt;imm&gt;]!</code></strong></p>

<p><strong>Signed Offset</strong>
<strong><code class="language-plaintext highlighter-rouge">STGP &lt;Xt1&gt;, &lt;Xt2&gt;, [&lt;Xn|SP&gt;{, #&lt;imm&gt;}]</code></strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;Xt1&gt;</code> Is the 64-bit name of the first general-purpose register to be transferred, encoded in the “Xt” field.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;Xt2&gt;</code> Is the 64-bit name of the second general-purpose register to be transferred, encoded in the “Xt2” field.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;Xn|SP&gt;</code> Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the “Xn” field.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;imm&gt;</code> For the post-index and pre-index variant: is the signed immediate offset, a multiple of 16 in the range -1024 to 1008, encoded in the “simm7” field.
For the signed offset variant: is the optional signed immediate offset, a multiple of 16 in the range -1024 to 1008, defaulting to 0 and encoded in the “simm7” field.</li>
</ul>

<hr />

<blockquote>
  <p>Add with Tag adds an immediate value scaled by the Tag granule to the address in the source register, modifies the Logical Address Tag of the address using an immediate value, and writes the result to the destination register.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">ADDG &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, #&lt;uimm6&gt;, #&lt;uimm4&gt;</code></strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;Xd|SP&gt;</code> Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the “Xd” field.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;Xn|SP&gt;</code> Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the “Xn” field.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;uimm6&gt;</code> Is an unsigned immediate, a multiple of 16 in the range 0 to 1008, encoded in the “uimm6” field.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;uimm4&gt;</code> Is an unsigned immediate, in the range 0 to 15, encoded in the “uimm4” field.</li>
</ul>

<hr />

<blockquote>
  <p>Subtract with Tag subtracts an immediate value scaled by the Tag granule from the address in the source register, modifies the Logical Address Tag of the address using an immediate value, and writes the result to the destination register.</p>
</blockquote>

<p><strong><code class="language-plaintext highlighter-rouge">SUBG &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, #&lt;uimm6&gt;, #&lt;uimm4&gt;</code></strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;Xd|SP&gt;</code> Is the 64-bit name of the destination general-purpose register or stack pointer, encoded in the “Xd” field.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;Xn|SP&gt;</code> Is the 64-bit name of the source general-purpose register or stack pointer, encoded in the “Xn” field.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;uimm6&gt;</code> Is an unsigned immediate, a multiple of 16 in the range 0 to 1008, encoded in the “uimm6” field.</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;uimm4&gt;</code> Is an unsigned immediate, in the range 0 to 15, encoded in the “uimm4” field.</li>
</ul>

<p>There are also instructions specifically so the system can use these specially tagged memory allocations, but they will not be covered here.</p>

<h2 id="how-impenetrable-is-this">How impenetrable is this?</h2>

<p>At the surface it seems like a very secure feature that would mitigate multiple routes of attack, so where will bugs exist?</p>

<p>It is possible that while reviewing the specification sheet someone will find an issue in the theorhetical implimentation, such as <a href="https://siguza.github.io/PAN/">siguza</a> found with another ARM feature, PAN (Priviledged Acess Never).</p>

<p>However, it is more likely that the manufacturer designing and implimenting the feature into their hardware and software will unknowingly make it insecure through an oversight in code review, or ignoring something entirely. Apple had a mishap like this in their implimentation of PAC (Pointer Authentication Codes) on iOS devices, as discovered by Brandon Azad of Google Project Zero in his <a href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html">fantastic teardown of Apple’s implimentation</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>While the hardware with Memory Tagging implimented isn’t in the public’s hands yet (is it?), when it is, it will certainly be a challenge for anyone looking to exploit vulnerabilities on this new hardware. However, <a href="https://twitter.com/qwertyoruiopz/status/1229837792370360324">one researcher isn’t scared quite yet</a>, and has been around long enough to hear about the impossibility of bypassing other “unhackable” features.</p>

<p>Please contact me on twitter if there are any problems with this post, or if you have any questions or reccomendations!</p>

<h3 id="references">References</h3>

<p><a href="https://llvm.org/devmtg/2018-10/slides/Serebryany-Stepanov-Tsyrklevich-Memory-Tagging-Slides-LLVM-2018.pdf">Memory Tagging: how it improves C/C++ memory safety</a></p>

<p><a href="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/arm-a-profile-architecture-2018-developments-armv85a">Arm A-Profile Architecture Developments 2018: Armv8.5-A</a></p>

<p><a href="https://static.docs.arm.com/ddi0487/fa/DDI0487F_a_armv8_arm.pdf">Arm® Architecture Reference Manual - Armv8, for Armv8-A architecture profile</a></p>

<p><a href="https://developer.arm.com/architectures/cpu-architecture/a-profile/-/media/Arm%20Developer%20Community/PDF/Arm_Memory_Tagging_Extension_Whitepaper.pdf">Armv8.5-A  Memory Tagging Extension (White Paper)</a></p>

<p><a href="https://seqred.pl/en/memory-tagging-extension/">In Q4 2018 ARM announced new architecture Armv8.5-A…</a></p>

<p><a href="https://twitter.com/qwertyoruiopz/status/1229837792370360324">qwertyoruiopz on twitter</a></p>
