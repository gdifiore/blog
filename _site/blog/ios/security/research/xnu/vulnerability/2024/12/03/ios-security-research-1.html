<p>While exploring differences between XNU versions, I stumbled upon a patched memory management bug. Surprisingly, a detailed comment left by Apple provided the key to uncovering a subtle yet critical vulnerability impacting memory safety.</p>

<h2 id="notes">Notes</h2>

<p>If you want to explore yourself you need to:</p>

<p>Download:</p>
<ul>
  <li>the sources for <code class="language-plaintext highlighter-rouge">xnu-6153.121.1</code> and <code class="language-plaintext highlighter-rouge">xnu-6153.141.1</code> (available at <a href="opensource.apple.com">opensource.apple.com</a>)</li>
  <li>a tool to diff directories/files</li>
</ul>

<p>This article also assumes that the reader has knowledge of MacOS, mach, IPC, C code, etc.</p>

<h2 id="a-small-observation">A Small Observation</h2>

<p>Traversing through the XNU sources with <code class="language-plaintext highlighter-rouge">WinDiff</code> revealed that <code class="language-plaintext highlighter-rouge">/osfmk/ipc/ipc_kmsg.c</code> is not the same between versions, meaning that maybe a bug was patched, or maybe it was just a typo that an OCD programmer felt the need to correct.</p>

<p>However, the side view revealed a 52 line difference between files, so it can’t be just a typo. But while reviewing the code I noticed a…</p>

<h2 id="big-comment">Big Comment</h2>

<p>Apple was kind enough to leave behind a comment explaining exactly what problem the code fixed!</p>

<p>The comment left in <code class="language-plaintext highlighter-rouge">ipc_kmsg_copyout_ool_descriptor</code> reveals that the issue stems from the mismanagement of offsets during deallocation. Apple’s note explains how a physical copy into a rounded range could leak memory if the size being deallocated doesn’t cover the full range.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * vm_map_copy_overwrite does a full copy
 * if size is too small to optimize.
 * So we tried skipping the offset adjustment
 * if we fail the 'size' test.
 *
 * if (size &gt;= VM_MAP_COPY_OVERWRITE_OPTIMIZATION_THRESHOLD_PAGES * ctive_page_size) {
 *
 * This resulted in leaked memory especially on the
 * older watches (16k user - 4k kernel) because we
 * would do a physical copy into the start of this
 * rounded range but could leak part of it
 * on deallocation if the 'size' being deallocated
 * does not cover the full range. So instead we do
 * the misalignment adjustment always so that on
 * deallocation we will remove the full range.
 */</span>
</code></pre></div></div>

<p>Now let’s take a look at the code to see what this is talking about.</p>

<h2 id="size-matters"><code class="language-plaintext highlighter-rouge">size</code> Matters</h2>

<p>In the previous version of XNU (<code class="language-plaintext highlighter-rouge">xnu-6153.121.1</code>), the (interesting part of the) function is:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mach_msg_descriptor_t</span> <span class="o">*</span> <span class="nf">ipc_kmsg_copyout_ool_descriptor</span><span class="p">(</span><span class="n">mach_msg_ool_descriptor_t</span> <span class="o">*</span><span class="n">dsc</span><span class="p">,</span> <span class="n">mach_msg_descriptor_t</span> <span class="o">*</span><span class="n">user_dsc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_64bit</span><span class="p">,</span> <span class="n">vm_map_t</span> <span class="n">map</span><span class="p">,</span> <span class="n">mach_msg_return_t</span> <span class="o">*</span><span class="n">mr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">vm_map_copy_t</span>                       <span class="n">copy</span><span class="p">;</span>
	<span class="n">vm_map_address_t</span>                    <span class="n">rcv_addr</span><span class="p">;</span>
	<span class="n">mach_msg_copy_options_t</span>             <span class="n">copy_options</span><span class="p">;</span>
	<span class="n">vm_map_size_t</span>                       <span class="n">size</span><span class="p">;</span>
	<span class="n">mach_msg_descriptor_type_t</span>  <span class="n">dsc_type</span><span class="p">;</span>

	<span class="c1">//SKIP_PORT_DESCRIPTORS(saddr, sdsc_count);</span>

	<span class="n">copy</span> <span class="o">=</span> <span class="p">(</span><span class="n">vm_map_copy_t</span><span class="p">)</span><span class="n">dsc</span><span class="o">-&gt;</span><span class="n">address</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">vm_map_size_t</span><span class="p">)</span><span class="n">dsc</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="n">copy_options</span> <span class="o">=</span> <span class="n">dsc</span><span class="o">-&gt;</span><span class="n">copy</span><span class="p">;</span>
	<span class="n">assert</span><span class="p">(</span><span class="n">copy_options</span> <span class="o">!=</span> <span class="n">MACH_MSG_KALLOC_COPY_T</span><span class="p">);</span>
	<span class="n">dsc_type</span> <span class="o">=</span> <span class="n">dsc</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">!=</span> <span class="n">VM_MAP_COPY_NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kern_return_t</span> <span class="n">kr</span><span class="p">;</span>

		<span class="n">rcv_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vm_map_copy_validate_size</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="n">FALSE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">"Inconsistent OOL/copyout size on %p: expected %d, got %lld @%p"</span><span class="p">,</span>
			    <span class="n">dsc</span><span class="p">,</span> <span class="n">dsc</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">copy</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">kr</span> <span class="o">=</span> <span class="n">vm_map_copyout_size</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcv_addr</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="c1">// ...</span>
</code></pre></div></div>
<p>The interesting part of the above code is the last few lines, so first let’s take a look at what <code class="language-plaintext highlighter-rouge">vm_map_copy_validate_size()</code> does.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Returns true if *size matches (or is in the range of) copy-&gt;size.
 * Upon returning true, the *size field is updated with the actual size of the
 * copy object (may be different for VM_MAP_COPY_ENTRY_LIST types)
 */</span>
<span class="n">boolean_t</span>
<span class="nf">vm_map_copy_validate_size</span><span class="p">(</span>
	<span class="n">vm_map_t</span>		<span class="n">dst_map</span><span class="p">,</span>
	<span class="n">vm_map_copy_t</span>		<span class="n">copy</span><span class="p">,</span>
	<span class="n">vm_map_size_t</span>		<span class="o">*</span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">==</span> <span class="n">VM_MAP_COPY_NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="n">vm_map_size_t</span> <span class="n">copy_sz</span> <span class="o">=</span> <span class="n">copy</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="n">vm_map_size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="o">*</span><span class="n">size</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">copy</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">VM_MAP_COPY_OBJECT</span><span class="p">:</span>
	<span class="k">case</span> <span class="n">VM_MAP_COPY_KERNEL_BUFFER</span><span class="p">:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sz</span> <span class="o">==</span> <span class="n">copy_sz</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">VM_MAP_COPY_ENTRY_LIST</span><span class="p">:</span>
		<span class="cm">/*
		 * potential page-size rounding prevents us from exactly
		 * validating this flavor of vm_map_copy, but we can at least
		 * assert that it's within a range.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_sz</span> <span class="o">&gt;=</span> <span class="n">sz</span> <span class="o">&amp;&amp;</span>
		    <span class="n">copy_sz</span> <span class="o">&lt;=</span> <span class="n">vm_map_round_page</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">VM_MAP_PAGE_MASK</span><span class="p">(</span><span class="n">dst_map</span><span class="p">)))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">size</span> <span class="o">=</span> <span class="n">copy_sz</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">vm_map_copy_validate_size</code> checks that the <code class="language-plaintext highlighter-rouge">size</code> field aligns with the actual size of the <code class="language-plaintext highlighter-rouge">vm_map_copy_t</code> object. However, its behavior differs based on the type of copy:</p>

<ul>
  <li>For <code class="language-plaintext highlighter-rouge">VM_MAP_COPY_OBJECT</code> and <code class="language-plaintext highlighter-rouge">VM_MAP_COPY_KERNEL_BUFFER</code>, it checks for exact matches.</li>
  <li>For <code class="language-plaintext highlighter-rouge">VM_MAP_COPY_ENTRY_LIST</code>, it allows ranges due to page-size rounding.</li>
</ul>

<p>Page size mismatches (e.g., 16k user vs. 4k kernel) introduce misalignment risks. If the size field doesn’t account for the full memory range during deallocation, leftover memory remains inaccessible but allocated, leading to leaks.</p>

<p>If size doesn’t match the rounded range, the kernel might only partially deallocate memory, leading to leaks.</p>

<p>But there isn’t anything inherently wrong with that, because <code class="language-plaintext highlighter-rouge">vm_map_copy_validate_size()</code> says that</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * potential page-size rounding prevents us from exactly
 * validating this flavor of vm_map_copy, but we can at least
 * assert that it's within a range.
 */</span>
</code></pre></div></div>
<p>Anyways, let’s continue to step through the code with <code class="language-plaintext highlighter-rouge">vm_map_copyout_size()</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 *	Routine:	vm_map_copyout_size
 *
 *	Description:
 *		Copy out a copy chain ("copy") into newly-allocated
 *		space in the destination map. Uses a prevalidated
 *		size for the copy object (vm_map_copy_validate_size).
 *
 *		If successful, consumes the copy object.
 *		Otherwise, the caller is responsible for it.
 */</span>
<span class="n">kern_return_t</span>
<span class="nf">vm_map_copyout_size</span><span class="p">(</span>
	<span class="n">vm_map_t</span>		<span class="n">dst_map</span><span class="p">,</span>
	<span class="n">vm_map_address_t</span>	<span class="o">*</span><span class="n">dst_addr</span><span class="p">,</span>	<span class="cm">/* OUT */</span>
	<span class="n">vm_map_copy_t</span>		<span class="n">copy</span><span class="p">,</span>
	<span class="n">vm_map_size_t</span>		<span class="n">copy_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vm_map_copyout_internal</span><span class="p">(</span><span class="n">dst_map</span><span class="p">,</span> <span class="n">dst_addr</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">copy_size</span><span class="p">,</span>
	                               <span class="n">TRUE</span><span class="p">,</span> <span class="cm">/* consume_on_success */</span>
	                               <span class="n">VM_PROT_DEFAULT</span><span class="p">,</span>
	                               <span class="n">VM_PROT_ALL</span><span class="p">,</span>
	                               <span class="n">VM_INHERIT_DEFAULT</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>So it’s supposed to copy <code class="language-plaintext highlighter-rouge">copy</code> into a new area of memory (<code class="language-plaintext highlighter-rouge">dst_map</code>) of address <code class="language-plaintext highlighter-rouge">*dst_addr</code> with size <code class="language-plaintext highlighter-rouge">copy_size</code>. But what’s the problem with that?</p>

<p><code class="language-plaintext highlighter-rouge">ipc_kmsg_copyout_ool_descriptor()</code> doesn’t implement a proper check if <code class="language-plaintext highlighter-rouge">copy_size</code> covers the entire range of memory needed (beyond <code class="language-plaintext highlighter-rouge">vm_map_copy_validate_size()</code>).</p>

<p>If the offset for <code class="language-plaintext highlighter-rouge">size</code> is not adjusted to cover the entire range of memory, when a physical copy happens at the start of the <em>rounded</em> (not true) range, and the <code class="language-plaintext highlighter-rouge">size</code> passed doesn’t cover the full range, it can leak memory when deallocated.</p>

<p>To fix this, XNU (<code class="language-plaintext highlighter-rouge">xnu-6153.141.1</code>) implemented a check if <code class="language-plaintext highlighter-rouge">size</code> is correct:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ...</span>
    <span class="n">boolean_t</span>                           <span class="n">misaligned</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="c1">// ...</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">copy</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">VM_MAP_COPY_ENTRY_LIST</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">trunc_page</span><span class="p">(</span><span class="n">copy</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">)</span> <span class="o">!=</span> <span class="n">copy</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">||</span>
		    <span class="n">round_page</span><span class="p">(</span><span class="n">dsc</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dsc</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">misaligned</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">misaligned</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">vm_map_address_t</span>        <span class="n">rounded_addr</span><span class="p">;</span>
			<span class="n">vm_map_size_t</span>   <span class="n">rounded_size</span><span class="p">;</span>
			<span class="n">vm_map_offset_t</span> <span class="n">effective_page_mask</span><span class="p">,</span> <span class="n">effective_page_size</span><span class="p">;</span>

			<span class="n">effective_page_mask</span> <span class="o">=</span> <span class="n">VM_MAP_PAGE_MASK</span><span class="p">(</span><span class="n">map</span><span class="p">);</span>
			<span class="n">effective_page_size</span> <span class="o">=</span> <span class="n">effective_page_mask</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">rounded_size</span> <span class="o">=</span> <span class="n">vm_map_round_page</span><span class="p">(</span><span class="n">copy</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">effective_page_mask</span><span class="p">)</span> <span class="o">-</span> <span class="n">vm_map_trunc_page</span><span class="p">(</span><span class="n">copy</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">effective_page_mask</span><span class="p">);</span>

			<span class="n">kr</span> <span class="o">=</span> <span class="n">vm_allocate_kernel</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="p">(</span><span class="n">vm_offset_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">rounded_addr</span><span class="p">,</span> <span class="n">rounded_size</span><span class="p">,</span> <span class="n">VM_FLAGS_ANYWHERE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">kr</span> <span class="o">==</span> <span class="n">KERN_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*
				 * vm_map_copy_overwrite does a full copy
				 * if size is too small to optimize.
				 * So we tried skipping the offset adjustment
				 * if we fail the 'size' test.
				 *
				 * if (size &gt;= VM_MAP_COPY_OVERWRITE_OPTIMIZATION_THRESHOLD_PAGES * effective_page_size) {
				 *
				 * This resulted in leaked memory especially on the
				 * older watches (16k user - 4k kernel) because we
				 * would do a physical copy into the start of this
				 * rounded range but could leak part of it
				 * on deallocation if the 'size' being deallocated
				 * does not cover the full range. So instead we do
				 * the misalignment adjustment always so that on
				 * deallocation we will remove the full range.
				 */</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">rounded_addr</span> <span class="o">&amp;</span> <span class="n">effective_page_mask</span><span class="p">)</span> <span class="o">!=</span>
				    <span class="p">(</span><span class="n">copy</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="n">effective_page_mask</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/*
					 * Need similar mis-alignment of source and destination...
					 */</span>
					<span class="n">rounded_addr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">copy</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="n">effective_page_mask</span><span class="p">);</span>

					<span class="n">assert</span><span class="p">((</span><span class="n">rounded_addr</span> <span class="o">&amp;</span> <span class="n">effective_page_mask</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">copy</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="n">effective_page_mask</span><span class="p">));</span>
				<span class="p">}</span>
				<span class="n">rcv_addr</span> <span class="o">=</span> <span class="n">rounded_addr</span><span class="p">;</span>

				<span class="n">kr</span> <span class="o">=</span> <span class="n">vm_map_copy_overwrite</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">rcv_addr</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">kr</span> <span class="o">=</span> <span class="n">vm_map_copyout_size</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rcv_addr</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="c1">// ...</span>
</code></pre></div></div>

<p>The specific fix is contained in one line:</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="p">(</span><span class="n">rounded_addr</span> <span class="o">&amp;</span> <span class="n">effective_page_mask</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">copy</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="n">effective_page_mask</span><span class="p">)</span>
</code></pre></div></div>
<p>By ensuring the size field is adjusted for alignment issues, they prevent partial deallocation.</p>

<h2 id="exploitation">Exploitation</h2>

<p>The comment specifically references older Apple Watches as vulnerable to this (due to the mismatch of user &amp; kernel page sizes). This is an issue, for example, large user pages split into smaller kernel pages increase the likelihood of misalignment.</p>

<p>One potential technique may be using mach messages.</p>

<p>Vulnerability Trigger:</p>
<ul>
  <li>An attacker crafts a mach message with a mismatched size field in the out-of-line (OOL) descriptor.</li>
  <li>This message is passed to the kernel for processing. If the misalignment adjustment isn’t applied, the kernel fails to deallocate the full range.</li>
</ul>

<p>Exploitation Goals:</p>
<ul>
  <li>Denial-of-Service: By repeatedly triggering the leak, attackers could exhaust kernel memory, leading to a system crash.</li>
  <li>Information Disclosure (potential): Depending on what memory is leaked, it might reveal sensitive data.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Was this comment intentional?</p>

<p>We may never know, but it gave insight into the work of an Apple employee, and may be a first step for someone wanting to learn vulnerability research and exploitation.</p>

<h3 id="references">References</h3>
<p><a href="http://web.mit.edu/darwin/src/modules/xnu/osfmk/man/mach_msg_descriptor.html">(MIT) mach_msg_descriptor</a></p>

<p><a href="https://www.freebsd.org/cgi/man.cgi?query=copyout&amp;apropos=0&amp;sektion=9&amp;manpath=FreeBSD+11-current&amp;format=html">(FreeBSD) COPY</a></p>

<p><a href="http://newosxbook.com/xxr/index.jl">(Jonathan Levin) XXR - The XNU Xref</a></p>
